### 문제
45656이란 수를 보자.
이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.
N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

### 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

### 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.


## 문제출력
1. 규칙을 찾아 점화식 만들기
2. top-down방식으로 재귀 만들기
3. memoization 배열 만들기

몇 가지 조건을 알아보도록 하자.
길이가 3인 계단 수에 대해 구한다면 123, 345 등등이 사용될 것이다.   
여기서 123을 살펴보면 3번째 자리의 값은 1, 두 번째 자리는 20, 첫번 째 자리는 3이 될것이다.  
다른 조건으로는 인접한 모든 자리의 차이가 1이라는 것인데, 이것을 살펴보면 만약 0일 경우   
다음으로는 1 밖에 오지못할 것이다. [-1이 올 수 없기 때문에] 다음으로는 9 다음으로는 8밖에 못 올것이다. [10이 못오기 때문에]   
예를 들어 10 다음으로는 101, 89 다음으로는 898 밖에 올 수 없다는 말이다.   
나머지 수 2~8 까지는 +1,-1 값을 가질 수 있다.   
여기서는 2차원배열을 사용해야 하는데, 2차원 배열을 사용하는 이유는 [N번쨰 자리]의 [자릿값]을 표현하기 위해서 이다.   
여기서 N번째 자리는 입력을 받을 것이고 해당 N번 째 자리에 들어가는 값들은 0 ~ 9 까지 일 것이다.  
따라서 배열로 표현하면 [Long[N + 1][10]]이다.    
여기서 N + 1 인 이유는 인덱스는 0부터 시작이고, 자연수는 1부터 시작이기 떄문이다.   
10또한 같은 이유로 9가 아닌 10의 크기를 갖는 것이다.   

여기서 헷갈릴 수 있는데, 2차원 배열에서 첫 번째 배열은 자릿수에 해당한다.  아래에서 예를 들어보자    
만약 10123 이란 숫자가 있다고 가정할 때   
숫자:     1         0        1   2   3    
자리:     5번째자리  4번째자리  3.. 2.. 1    
이렇게 표현이 가능할텐데, 배열같은 경우 왼쪽에서 오른쪽으로 읽는데, 여기서는 다르게    
인덱스를 마치 N번째 자리에 해당하는 값이라고 생각하면 쉽게 이해할 수 있다. 다시말해,   
10123일 때     
숫자:    1   0   1   2   3  
인덱스:  5   4   3   2   1  
자리:    5   4   3   2   1    
이런식으로 값이 들어가게 된다.   

다음으로 1자리만 주어진다면 1 ~9 가 가능하며, 계단 수는 각각 1이 된다.   
[1][1] ~ [1][9] = 1;   

이제 조건을 가지고 재귀함수를 만든다면 아래와 같을 것이다.   
재귀함수는 2가지 인수를 갖는데, 하나는 자릿수에 해당하는 digit과 해당 자리에 할당되어있는 자릿값 val이다.
위에 보았듯이 1자리만 주어졌을 때 1이 모두 할당되었으니 재귀의 종료시점은 digit이 1일 때이다.   

```java
private static long recur(int digit, int val) {

    if(digit == 1) {
        return dp[digit][val];
    }
}
```
다음으로는 0과 9에 대한 조건이다. 자리수 N에 대하여 0일 때 뒤에는 1밖에 오지못한다는 점과    
9일 때 뒤로는 8밖에 못오는 점이다.       
위에서 설명했듯이 이차원배열의 첫 번째 배열은 N번 째 자리를 나타내는 것이다.   
예를들어서     
숫자:   1   0   1   
자리:   3   2   1  
인덱스: 3   2   1   
따라서 digit - 1를 이해하자면 2째 자리가 0 일때 다음 첫 째 자리로는 1 만 올 수 있기 때문에   
digit - 1, 1이 오게되는 것이다.

```java
if(val == 0) {
    dp[digit][val] = recur(digit - 1, 1) % mod;
} else if (val == 9){
    dp[digit][val]=recur(digit-1, 8) % mod;
}
```
0,9를 제외한 수는 +1, -1를 가질 수 있다.

```java
} else {
    dp[digit][val] = (recur(digit - 1, val - 1) + recur(digit - 1, val + 1)) % mod;
}
```
참고한 블로그에서 모듈러연산을 사용하였는데, 모듈러연산에 대해 짧게 설명하자면   
% 연산에 대한 나머지 값이 같다는 것이다.   
3 % 10 과 13 % 10의 결과 값이 같다는 것이다.    
%연산에 대해서 몫은 중요하지 않고, 나머지가 같은 값이 나온다는 것을 설명한다.    
A % B 에 대해서 A에 B를 여러번 더해도 같은 결과가 나온다는 것이다.   
3 % 10, 13 % 10, 23 % 10 ...,  
이것을 가지고 값이 long이 넘어갈 수도 있기 때문에 dp[][]에 저장을 할 때 % mod 만큼하여 저장한다.    
결과에서도 % mod한 값을 출력하기 때문이다.     
mod값이 10,000일 경우 10,007 % 10,000 에서의 결과는 7이고    
7 % 10,000 에서의 결과도 7로 동일하기 때문이다.   

- N을 입력받는다.
  - 모드 계산할 값과 memoization 배열을 선언한다.
```java
static Long[][] dp;
static long mod = 1000000000;
        
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

int N = Integer.parseInt(br.readLine());

//배열 생성
dp = new Long[N + 1][10];

```
- 초기값을 설정한다.
  - 여기서 초기값은 첫째 자리에 대해 0~9의 값을 1로 초기화한다.
```java
for(int i = 0; i < 10; i++) {
    dp[1][i] = 1L;
}
```
- N째 자리에 대해 1 ~ 9 까지의 계단수를 출력한다.
  - 여기서 1 ~ 9 까지의 범위인 이유는 0으로 시작하는 수는 계단수가 아니라는 조건이 있기 때문에   
  - 1 ~ 9 까지의 범위가 들어가는 것이다.
  - 예를 들어 N이 2일 때가 자리가 2자리, 즉 자연수로 보자면 10의 자리까지 나타낸다는 말인데   
  - 10의 자리에 0이 오는 것은 10의 자리에 해당하는 값이 될 수 없기 때문이다.
  - 따라서 dp[2][0] 에 대해 탐색하지 않기 때문에 고려하지 않아도 된다.   
  - 만약 2가 아닌 N > 2 클 때 재귀를 통해 dp[2][0]는 나올 수 있다.   
    - 101과 같은 값이 될 수 있기 때문에   
```java
long result = 0;

for(int i = 1; i <= 9; i++) {
    result += recur(N, i);
}
```

- 재귀함수를 선언한다.
  - digit은 N째자리의 수, val은 N째자리의 해당하는 값
  - memoization에 값이 할당되어있지 않다면 (==null)   
  - 0일 때는 1밖에 못오기 때문에 digit - 1, 1
  - 9일 때는 8밖에 못오기 때문에 digit - 1, 8
  - 나머지는 (digit - 1, val -1), (digit - 1, val + 1)
  - 배열에 할당할 때 %mod해서 저장하는 이유는 long을 넘어갈 수도 있고, 모듈러 연산으로 동일한 결과가 나오기 때문에
```java
private static long recur(int digit, int val) {

    if(digit == 1) {
        return dp[digit][val];
    }

    if(dp[digit][val] == null) {

        if(val == 0) {
            dp[digit][val] = recur(digit - 1, 1) % mod;
        } else if (val == 9) {
            dp[digit][val] = recur(digit - 1, 8) % mod;
        } else {
            dp[digit][val] = (recur(digit - 1, val - 1) + recur(digit - 1, val + 1)) % mod;
        }
    }

    return dp[digit][val];
}
```







##### 출처: https://st-lab.tistory.com/134