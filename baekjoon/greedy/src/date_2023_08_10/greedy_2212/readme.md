### 문제
한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.
각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.
편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.   

### 입력
첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.  

### 출력
첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.  

## 문제 해결
이 문제는 문제의 풀이를 먼저 센서의 수와 집중국의 수가 같을 때 부터 생각해면 쉽게 풀 수 있다.    
집중국의 수 K 가 센서의 수 N보다 크거나 같다면 [K >= N]각각의 집중국이 센서를 담당하면 된다. 즉, 길이의  최솟값은 0이된다.   
여기서 주목해야하는 점은 집중국이 각각의 센서를 담당하면 거리가 0이된다는 점이다.  
그렇다면 집중국의 수가 센서의 수 보다 작을때는 어떻게 풀면 될까.   
먼저 센서를 오름차순으로 정렬한다.    
그런다음 각각의 센서간의 거리차이를 구한다.  
그런다음 거리가 가장 먼 센서에 대해 해당 센서에는 1개의 집중국을 두어 센서 간의 거리에 대한 값을 0으로 만드는 것이다.     
그렇게 거리가 먼 센서에 대해 각각의 집중국을 배분하고 남은 집중국 한 개로 나머지 거리를 모두 커버하게 되는 것이다.   
다시말해, 거리차이가 먼 센서에는 개별 집중국을 부여하고, 센서에 모두 부여하고 남은 마지막 1개로 나머지 거리에 대한 센서들을 모두 커버하면 된다.   
해당 내용은 아래 그림을 참고하면 쉽게 이해할 수 있다.  
아래 그림은 예제 입력1을 참고하여 만든 그림이다.
![스크린샷 2023-08-10 오후 6 43 52](https://github.com/xxx-sj/algorithm/assets/62305110/ecd41d9c-e54a-41bc-bf43-f2271b35b1a5)

예제 입력2를 대상으로 새로 만든다면 아래와 같다.   
![image](https://github.com/xxx-sj/algorithm/assets/62305110/3b7bd870-6f50-4ebd-95eb-db28e85b4d4d)
![image](https://github.com/xxx-sj/algorithm/assets/62305110/35cdbce3-db95-41a0-921e-58196537a8e0)

- 센서 수 N과 집중국 K를 입력받는다.
```java
 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

int N = Integer.parseInt(br.readLine());
int K = Integer.parseInt(br.readLine());
```
- N만큼 배열을 만들어 다음으로 입력받는 센서의 위치를 배열에 할당한다.
```java
int[] location = new int[N];
StringTokenizer st = new StringTokenizer(br.readLine(), " ");
for(int i = 0; i < N; i++) {
    location[i] = Integer.parseInt(st.nextToken());
}
```
- 센서 배열을 오름차순으로 정렬한다.
- 다음으로 각 센서간의 거리 차이 [diff] 저장할 배열을 만든다.
  - diff 배열의 크기는 N -1 이다.
    - N -1 인 이유는 각 센서간의 거리차이를 저장하기 때문에 N -1 이다.
    - 예를들어 센서가 3개라면 3개 간의 거리 차이 값은 2개가 나오기 때문이다.
- 현재 배열과 그 다음배열간의 값의 차이를 구하는 것이기 때문에
- for loop의 범위는 0 ~ (N - 1 - 1) 까지 순회한다.
  - -1을 2번 하는데, 첫 번째 -1의 의미는 배열의 길이[크기]는 1부터 시작하지만 배열의 인덱스는0부터 시작하기 때문이다.
  - 다음 -1은 현재 배열과 다음 배열을 비교해서 차이를 diff배열에 저장해야 하는데, N -1 까지 한다면 
  - 현재 배열 [N -1] 다음 배열 [N] 이므로 다음배열 [N] 에서 배열의 크기를 넘기면서 에러를 뱉기 때문이다.
- 뺀 값을 저장한 배열도 오름차순으로 정렬한다.
```java
int[] diff = new int[N - 1];

for(int i = 0; i < N - 1; i++) {
    diff[i] = location[i + 1] - location[i];
}
Arrays.sort(diff);
```
- 마지막으로 diff[] 배열을 순회하는데 
- 인덱스 0번 부터 diff.length - (K - 1) 보다 작을때까지 순회하며 결과에 누적하여 더한다.
  - 여기서 diff.length - (K - 1)를 하나씩 살펴보면
  - for (int i = 0; i < diff.length - (K -1); i++) 에서 
  - diff.length 만 있다면, diff의 모든 인덱스를 순회한다는 의미이고
  - diff.length - K 만 있었다면, 이 전에 말했던 마지막에 남은 1개의 집중국이
  - 나머지 센서들을 맡는것이 아닌 큰 수들에 대해 모두 집중국을 담당하게 만들게 된다.
  - 따라서 마지막 1개가 나머지 센서들을 담당할 수 있게 -1을 더 해주는 것이다.
  - diff.length - K - 1 이 되는 것이다.
```java
int result = 0;
for(int i = 0; i < diff.length - (K - 1); i++) {
    result += diff[i];
}

System.out.println(result);
```