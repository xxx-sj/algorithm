### 문제
병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.  
1. 2칸 위로, 1칸 오른쪽  
2. 1칸 위로, 2칸 오른쪽  
3. 1칸 아래로, 2칸 오른쪽  
4. 2칸 아래로, 1칸 오른쪽  
병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다.    
이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다. [move > 4 | (count < 5)]  
체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.  

### 입력
첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.  

### 출력
병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.  


## 문제해결
이 문제에 대해서는 몇가지를 알고 들어간다면 쉽게 풀이할 수 있다.   
먼저 방문할 최대의 칸을 이동하기 위해서는 오른쪽으로 1칸씩 이동하는 것이 가장 효율적이란 점이다.   
이 개념을 베이스에 두고 몇가지 조건을 살펴보자.  
첫 번째로는 N[세로]의 길이가 1이 들어왔을 때이다.   
이때는 위,아래로 이동하지 못하므로 방문할 수 있는 칸은 처음 1칸 1이된다. 아래 사진을 통해 확인 가능하다.   
두 번째로는 N[세로]의 길이가 2일 때이다.  
이때는 위, 아래로 이동이 가능하지만, 위에서의 이동조건 4가지 중 [2,3] 즉, 위, 아래로 한칸 씩만 이동이 가능하다.  
두 번째에서는 하나의 조건이 붙는데, 만약 이동횟수가 4번 이상일 경우[move >= 4] [방문한 칸의 갯수가 5개 이상일 때 (count >= 5)]는 이동조건 4가지를 모주 적어도 1번은 이동해야 한다.   
하지만 위, 아래로 1칸만 이동할 수 있는 조건이기때문에 1,4 이동은 불가능하다. 따라서 최대 방문 횟수는 4번까지가 최대이다.   
방문횟수가 4번이 넘어간다는 것은 [count > 4] 이동횟수가 [move >= 4] 라는 말이다.
![스크린샷 2023-08-10 오후 2.34.50.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-10%20%EC%98%A4%ED%9B%84%202.34.50.png)
세 번째로는 N[세로]가 3보다 크거나 같을 때이다.   
이때는 1,2,3,4 모두 위, 아래로 이동이 가능하다.   
그렇다면 가장 많이 방문하며 이동하기 위해서는 오른쪽으로 한칸 씩으로 이동해야한다. [2,3 이동 방법]
단, 조건이 생기는데, 위에서 말했듯이 이동이 4번 이상일 경우 이동방법을 적어도 1번씩은 사용하여 이동해야 한다.  
4가지 방법을 모두 사용하여 이동하려면 적어도 M[가로]의 크기가 7 >= M 이어야 한다. [아래 그림 참조]    
그렇다면 M 의 크기가 7보다 작다면 최대 방문 가능한 크기는 최대 4이며, 4를 넘을 수 없을 것이다.    
만약 크기가 7보다 크다면, 그 때는 위에 이동방식4번을 모두 이동한 후 위에서 말한 가장 많이 방문이 가능한 [2, 3]이동방법으로만 이동하면 최대로 방문이 가능하다.    
그렇다면 4번씩 이동할 때 오른쪽으로 2번씩 이동한 수가 2번이므로 M -2를 통해 최대 방문 수를 구할 수 있다. 여기서 -2 를하는 이유는   
최대한의 방문을 위해서는 오른쪽으로 한번씩만 이동해야 하지만 부득이하게 4번이동방법을 사용하면서 2번씩 이동하는것이 2번, 즉, 한번 당 오른쪽으로 1번씩 더 이동했기 때문에 -2를 하는 것이다.  
![스크린샷 2023-08-10 오후 2.35.06.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-10%20%EC%98%A4%ED%9B%84%202.35.06.png)
이것을 코드로 보면 아래와 같다.   


- N[가로] M[세로] 를 입력받는다.
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

StringTokenizer st = new StringTokenizer(br.readLine(), " ");
//가로
int N = Integer.parseInt(st.nextToken());
//세로
int M = Integer.parseInt(st.nextToken());
```

- 위에서 설명한 내용을 코드로 옮긴다.
- N이 1일경우 이동이 풀가 하므로 1을 반환한다.
- N이 2일경우는 최대 4곳을 방문가능하며, 4를 넘기지 못한다.
- N이 3보다 같거나 클 경우에는 M의 크기를 비교한다.
  - M이 7보다 크거나 같다면 적어도 한번 씩 이동방향을 사용할테고, 그 다음부터는 한칸씩 오른쪽으로 이동할 것이다. 
  - 따라서 M > 7 일때는 M -2 를 반환한다.
  - M이 7보다 작다면 최대 4번까지 방문이 가능하며, M번만큼 방문이 가능하다. 
    - 여기서 M번인 이유는 오른쪽으로 한칸 씩 이동하는 것이 최대한 많은 곳을 방문할 수 있기 때문이다.
      - M - 1이 아닌가 라고 생각할 수 있지만 처음 놓아지는 곳도 방문한 것으로 치기 때문에 M이 되는 것이다.
```java

int count = 0;
if(N == 1) {
    count = 1;
} else if (N == 2) {
    count = Math.min(4, (M + 1) / 2);
} else if (N >= 3) {
    if(M >= 7) {
        count = M - 2;
    } else {
        count = Math.min(4, M);
    }
}
System.out.println(count);
```