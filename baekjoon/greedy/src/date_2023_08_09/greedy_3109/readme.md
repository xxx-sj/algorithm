### 문제
유명한 제빵사 김원웅은 빵집을 운영하고 있다. 원웅이의 빵집은 글로벌 재정 위기를 피해가지 못했고, 결국 심각한 재정 위기에 빠졌다.  
원웅이는 지출을 줄이고자 여기저기 지출을 살펴보던 중에, 가스비가 제일 크다는 것을 알게되었다. 따라서 원웅이는 근처 빵집의 가스관에 몰래 파이프를 설치해 훔쳐서 사용하기로 했다.  
빵집이 있는 곳은 R*C 격자로 표현할 수 있다. 첫째 열은 근처 빵집의 가스관이고, 마지막 열은 원웅이의 빵집이다.  
원웅이는 가스관과 빵집을 연결하는 파이프를 설치하려고 한다. 빵집과 가스관 사이에는 건물이 있을 수도 있다. 건물이 있는 경우에는 파이프를 놓을 수 없다.  
가스관과 빵집을 연결하는 모든 파이프라인은 첫째 열에서 시작해야 하고, 마지막 열에서 끝나야 한다. 각 칸은 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선으로 연결할 수 있고, 각 칸의 중심끼리 연결하는 것이다.  
원웅이는 가스를 되도록 많이 훔치려고 한다. 따라서, 가스관과 빵집을 연결하는 파이프라인을 여러 개 설치할 것이다. 이 경로는 겹칠 수 없고, 서로 접할 수도 없다. 즉, 각 칸을 지나는 파이프는 하나이어야 한다.  
원웅이 빵집의 모습이 주어졌을 때, 원웅이가 설치할 수 있는 가스관과 빵집을 연결하는 파이프라인의 최대 개수를 구하는 프로그램을 작성하시오.  

### 입력
첫째 줄에 R과 C가 주어진다. (1 ≤ R ≤ 10,000, 5 ≤ C ≤ 500)  
다음 R개 줄에는 빵집 근처의 모습이 주어진다. '.'는 빈 칸이고, 'x'는 건물이다. 처음과 마지막 열은 항상 비어있다.  

### 출력
첫째 줄에 원웅이가 놓을 수 있는 파이프라인의 최대 개수를 출력한다. 


## 문제해결 법
책을 많이 읽이않아서 인지 문제를 파악하는데 오래 걸렸다.  쉽게말해 입력받는 행,렬에 대해서   
가장 왼쪽 세로 한 줄이 파이프의 시작점, 그리고 가장 오른쪽 세로 한 줄이 빵짐이란 점에서 시작한다.   
여기서 이동은 왼쪽에서 오른쪽으로만 가능하다. 또한 이동할 때는 오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선   
으로만 이동이 가능하다.  이것을 다시 행렬로 풀어서 표현하자면    
오른쪽 위 대각선은 행으로 -1, 열로 +1 이동하는 것이다.  
오른쪽 이동은 행으로 0, 열 + 1   
오른쪽 아래 대각선은 행 +1, 열 + 1 이동한다는 것을 알 수 있따.   
예를들어 시작점이 (1, 1) 이라면 각각 오른쪽 위 대각선은 [0, 2], 오른쪽은 [1, 2], 오른쪽 아래 대각선은 [2, 2]에 해당한다.   
이 문제는 그리디 알고리즘과 재귀를 통해 풀 수 있다.    
여기서 그리디 알고리즘이라고 말한 이유는 항상 시작은 왼쪽 세로 한줄 인데 각각 [0, 0], [1, 0], [2, 0]... 에 해당한다.   
[0,0]이 최초 시작 점이 될텐데, [0,0]으로 지날 수 있는 길을 먼저 다 표시 해 둔 후, 다음으로 [1, 0]을 할 때 [0,0]이 이미 지나간 길은   
통과할 수 없기 때문에 [0, 0]이 자신이 지날 수 있는 길만을 탐욕적으로 선택히였다 생각할 수 있으므로 그리디 알고리즘을 사용하였다고 쉽게 생각할 수 있다.  [아닐수도..]   
다시 돌아와서 [0, 0] 이 오른쪽 세로에 도달할 때까지의 이동을 보자면,    
먼저 [0,0]을 시작으로 오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선으로 이동을 진행한다. 만약 여기서 이동할 수 있는 구간이 있따면 해당 구간에 표시를 해두고 앞으로 이동하여 동일하게   
오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선으로 이동 할 수 있는지 확인해본다. 만약에 모두 이동이 불가능 하다면 뒤로 돌아가 이 전에 이동했던 부분을 제외한 다른 부분으로 이동을 한다.   
다시말해, 처음 오른쪽 위 대각선으로 이동 후, 다음으로 이동하려 할 때 세 곳 모두 이동이 불가하다면 다시 이동 전으로 돌아가   
오른쪽 위 대각선을 제외한 오른쪽 또는 오른쪽 아래 대각선으로 이동을 시도한다. 이동을하여 오른쪽 세로에 도달한다면 true를 반환하여 모든 파이프가 연결되었다는 것을 카운팅한다.   
이것을 코드로 보면  아래와 같다.   


- static 영역에 오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선으로 이동할 배열을 만든다.
  - 배열은 dr = {-1, 0, 1}; dc = {1, 1, 1} 이다.
    - 각각 오른쪽 위 대각선으로 이동시 row는 -1이 감소하고 col은 1이 증가한다.
    - 오른쪽 이동은 row = 0; col = 1;
    - 오른쪽 아래 대각선이동은 row = 1; col =1; 이다.
  - 입력받을 행열 int R, C;
  - 입력받은 행열로 만들 지도 map
  - 파이프가 지난자리가 있는지에 대한 visited 배열
- 행열을 입력받는다.
```java
static int[] dr = {-1, 0, 1};
static int[] dc = {1, 1, 1};
static int R, C;
static char[][] map;
static boolean[][] visited;

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

//행 열을 입력받는다.
StringTokenizer st = new StringTokenizer(br.readLine(), " ");
R = Integer.parseInt(st.nextToken());
C = Integer.parseInt(st.nextToken());
```
- 입력받은 행열로 map, visited 크기배열을 초기화하고 다음으로 map을 입력받는다.
  - map에는 파이프 설치 가능한 위치와 건물의 위치를 나타낸다.
```java
//파이프가 지나가는 자리에 대한 표시로 visited[][]을 초기화한다.
visited = new boolean[R][C];
//입력받은 행열 크기의 map을 초기화한다
map = new char[R][C];

//입력받은 행 열 만큼 배열을 만든다.
for(int i = 0; i < R; i++) {
    String temp = br.readLine();
    for(int j = 0; j < C; j++) {
        map[i][j] = temp.charAt(j);
    }
}
```
- 입력받은 행 만큼 loop를 돌면서 검증을 한다.
  - connectPipe 함수에(i, 0) 을 넘긴다.
    - i는 row에 해당하며 0은 col에 해당한다.
    - 항상 0을 넘기는 이유는 가장 왼쪽 세로줄에서 시작하기 때문이다.
  - connectPipe함수에서는 처음 재귀 종료의 조건을 추가한다.
    - 종료의 조건은 col 이 C- 1"[열의 마지막]"에 도달한다면 재귀를 종료한다.
    - 종료와 함께 visited를 true로 초기화하고 파이프를 연결했으므로 true를 반환한다.
  - 오른쪽으로 이동가능한 3가지 방향 만큼 for문을 돌리면서 이동한다.
  - 시작점에서 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선 이동을 하기위해
  - 입력받은 row, col에 각각 dr, dc를 더해 위의 3가지 방향으로 이동할 수 있도록 한다. 
  - 이때 이동한 위치에 대하여 isvalid 함수를 통해 검증을한다.
    - isValid는 이동한 위치에 대하여 row, col이 0보다 큰지, row, col이 입력받은 값보다 작은지에 대한 검증이다.
  - 다음으로 다른 검증은 이동한 위치에 대하여 visted가 true가 아닌지
    - true라면 이미 파이프가 지나간 자리이기 때문이다.
  - 마지막으로 이동한 위치에 건물이 없는지 map[row][col] == '.' 에 대해 검증한다.
  - 모두 통과하면 visited[newRow][newCol]에 true를 초기화하고
  - 다시 오른쪽으로 이동하기 위해 connectPipe를 재귀호출한다.
  - 재귀호출을 하다 오른쪽 끝 열에 도달 시 true가 반환되며 모든 재귀함수가 끝이나며 true를 connectPipe함수가 true를 반환하다
  - 반환받은 true로 인해 count를 하나 증가시킨다.
```java
int count = 0;
//행[row] 수 만큼 반복하며 이동을 시작한다.
//0으로 넘기는 이유는 시작부분이 가장 왼쪽 세로 부분이기때문에 열의 값은 항상 0이다.
for(int i = 0; i < R; i++) {

    if(connectPipe(i, 0)) {
        count++;
    }
}


private static boolean connectPipe(int row, int col) {

//재귀의 종료 시점을 설정한다.
// 이때 종룔 시점은 왼쪽에서 시작해 오른쪽으로 모두 이동하였다면 true를 반환한다.
//이 때 C - 1인 이유는 C는 열의 갯수이고, 우리가 알 수 있는건 index값이기 때문에
//C -1 을 해준다.
  if (col == C - 1) {
    visited[row][col] = true;
    return true;
  }

//3번 반복하는 이유는 이동방향이 [오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선] 3개 이기 때문이다.
  for (int i = 0; i < 3; i++) {
//입력받은 row, col을 이용해 앞으로 이동할 방향을 결정한다.
// 각각 위에서 선언한 오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선 순서대로 이동한다.
  int newRow = row + dr[i];
  int newCol = col + dc[i];

//isvalid함수를 통해 새로 이동하는 위치를 검증한다.
//isValid검증은 행 열에 대한 검증인데, 행 열이 0보다 큰지, 그리고
//입력받은 행렬 정보보다 커지지 않았는지에 대한 정보이다.
//예를들어 5x5 배열인데, 증가하다가 row 또는 col의 인덱스가 5가 되어버리면 입력값을 벗어나기 때문이다.
//두 번째로 체크하는 것은 이 전에 파이프에 해당 배열을 지나 갔는가 이다.
//지나갔다면 해당 위치로는 이동할 수 없기 때문이다.
//마지막으로 건물이 있는지 아닌지에 대한 판단이다. map 배열에 건물이 없다면 "." 있다면 'X'이다.
    if(isValid(newRow, newCol) && !visited[newRow][newCol] && map[newRow][newCol] == '.') {
//모두 통과하면 해당 위치에 이동할 수 있다는 의미[파이프 설치]이므로 visited 배열에 true를 입력한다.
      visited[newRow][newCol] = true;

      //새로운 위치로 이동하였으니 그 다음으로 이동해야 하기 때문에 connectPipe를 재귀로 호출한다.
      //이때는 만약 처음 입력받은 값이 (0,0)이고, 이동한 위치가 오른쪽 이라면
      // 다음으로 newRow, newCol이 (0,1)로 connectPipe에 전달된다.
      //전달된 값은 위의 검증을 거쳐 만약에 세 곳 모두로 이동할 수 없다면 돌아와
      //오른쪽 아래 대각선 이동에 대해 검증을 진행하게 된다.
      if(connectPipe(newRow, newCol)) {
        return true;
      }
    }
  }

  return false;
}

private static boolean isValid(int row, int col) {

    return row >= 0 && row < R && col >= 0 && col < C;
}
```