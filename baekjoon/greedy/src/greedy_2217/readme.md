# 문제
N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.
하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.
각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.

# 입력
첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.

# 출력
첫째 줄에 답을 출력한다.

### 해결 방법
k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때 모두 고르게 w/k만큼의 중량이 걸리게 된다 하였다.  
예를 들어서, 2, 10 ,15 의 로프가 있다면 최소로 들 수 있는 로프의 무게는 2이며, 총 무게는 2x3 = 6이 된다.  
하지만 여기서 조건으로 모든 로프를 사용해야 할 필요는 없다고 하였으니, 2를 제외한 10 또는 15으로 들게 되며, 최소 10으로 들 경우 총 무게는 20,   
15로 들게된다면 15 를 들 수 있을 것이다. 계산하기 위해 입력받은 N개의 로프는 오름차순으로 정렬한다.     
이것을 계산해보면 R * (N - idx)[총 로프의 갯수 - 현재 로프의 idx = 현재 로프보다 많거나 같은 중량을 들 수 있는 로프의 수] 의 무게를 들 수 있다.     
R은 로프가 들 수 이는 중량, N은 총 로프의 갯수, idx는 현재 계산 하는 로프의 idx 번호이다.

- N개의 로프의 갯수를 입력 받는다
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine());
```
- N번 순회하며 로프를 받는다.
  - 오름차순으로 정렬한다.
```java
int[] rope = new int[N];
for(int i = 0; i < N; i++) {
    rope[i] = Integer.parseInt(br.readLine());
}
Arrays.sort(rope);
```
- loop를 돌면서 max값을 계산한다.
  - max의 초깃값을 Integer.MIN_VALUE;로 초기화한 이유는 처음 계산되는 값을 대입하기 위해서이다. 
  - loop에서 이전 max값과 현재 계산값을 비교하여 max값을 구한다.
  -  rope[i] * (N - i) => rope[i] 현재 로프의 커버 중량 / N 총 로프의 개수 / i 현재 로프의 인덱스 값
    - N 에서 i를 빼는 이유는 오름차순으로 정렬된 배열에서 현재 로프의 값의 이 전 값들은 현재 로프의 값보다 작거나 같은 값들이기에 더 많은 무게를 들 수 없기 때문에
    이 후의 로프의 개수만을 계산하는 것이다. 
```java
int max = Integer.MIN_VALUE;

for(int i = 0; i < N; i++) {
    max = Math.max(max,(rope[i] * (N - i)));
}
```



