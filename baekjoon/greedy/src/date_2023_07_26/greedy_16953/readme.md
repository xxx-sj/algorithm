# 문제
정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.
2를 곱한다.
1을 수의 가장 오른쪽에 추가한다.
A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.

# 입력
첫째 줄에 A, B (1 ≤ A < B ≤ 109)가 주어진다.

# 출력
A를 B로 바꾸는데 필요한 연산의 최솟값에 1을 더한 값을 출력한다. 만들 수 없는 경우에는 -1을 출력한다.

2 162
2 -> 4 -> 8 -> 81 -> 162
4 42
4 -> 8 -> 16 -> 32 -> 64 -1
100 40021 
100 -> 200 -> 2001 -> 4002 -> 40021

##### 문제해결법
이 문제는 A 에서 B로 가는 값을 구하는 것보다, B에서 A값으로 가는 값을 도출하는 것이 쉽게 풀 수 있다.
주가 B가 되고, A까지 도달할 수 있는지를 구하며 값을 구해 나간다.   
여기서 조건은 
- 2를 곱한다
- 1를 가장 오른쪽에 추가한다. [1의 자리에 추가]
이다. 이걸 반대로 생각해보면
- 2로 나눈다.
- 1의 자리가 1일 경우 일의 자리 1을 뺀다.
이다.  
하나 조심해야 하는 것은 처음 풀 때는 B % 10, 만 고려하고 나머지 값은 모두 B / 2 를 했는데, 홀수인 경우를 고려해 주어야 한다.
반대로 계산해 가며 값을 구하기 때문에 2로 나눌수 없는 값에 대하여 [홀수] -1을 반환해야 한다.

- 값을 입력받고, A와 B로 나눈다.
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine(), " ");

long A = Long.parseLong(st.nextToken());
long B = Long.parseLong(st.nextToken());
```
- 최솟값에 사용할 cnt를 1로 초기화 하고 while문의 조건으로 A != B를 넣는다.
```java
int cnt = 1;
while(B != A) {
}
```
- while문 내에서의 조건은 계산되는 B의 값이 A보다 작다면 -1을 대입한다.
  - B가 A보다 작아진다면 A에 도달할 수 없기 때문이다.
```java
if (B < A) {
    cnt = -1;
    break;
}
```
- B를 10으로 나눠서 나머지가 1이 된다면 일의 자리가 1이므로 B에 10으로 나눈 몫을 대입한다.
- B를 2로 나누어서 떨어진다면 [나머지 0] B를 2로 나눈다.
- 위 조건이 모두 성립하지 않는다면 -1을 반환한다.
- 마지막에 cnt를 하나 증가 시킨다.
```jpaql
if (B % 10 == 1) {
    B = B / 10;
} else if (B % 2 == 0){
    B = B / 2;
} else {
    cnt = -1;
    break;
}
cnt++;
```


