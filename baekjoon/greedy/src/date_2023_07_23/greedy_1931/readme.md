# 문제
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.
# 입력
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.
# 출력
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

### 해결 방법
회의실을 이용하기 위해서는 종료 시간이 빠른순으로 정렬을 하면 된다.
2가지 방법으로는 2차원 배열을 사용하는 것과, 하나의 클래스를 선언하는 것이다.

#### 2차원 배열
- N개의 회의실을 받는다.
```java
Scanner sc = new Scanner(System.in);
int N = sc.nextInt();
```
- 다음으로 회의실의 시간시간과 종료 시간을 받는다.
- 이 때 회의실의 수는 N 시작과 종료 2개의 데이터를 받으므로
- int[N][2] 가 된다.
- 2차원 배열은 말 그대로 배열의 값으로 배열을 갖는것이다.
- int[0] 의 값으로 int[]을 갖는다는 뜻이다.
```java
int[][] time = new int[N][2];

for(int i = 0; i < N; i++) {
    timw[N][0] = sc.nextInt();
    time[N][1] = sc.nextInt();
}
```
- 이제 종료시간을 기준으로 2차원 배열을 정렬한다. 이때는 Comparator를 재정의한다.
```java
Arrays.sort(time, new Comparator<int[]>() {
    
    @Override
    // 위에서 말했듯이 2차원배열은 배열의 값으로 배열을 갖는것으로
    // 인자로 들어오는 값은 배열이 된다 int[0], int[1], int[2]...
    // 해당 배열의 값으로는 size2인 배열이 들어오는데 각각 시작시간, 종료시간을 나타낸다.
    // 다시말해서 처음부터 값을 비교한다고 생각하면
    // o1 에는 int[0]에 해당하는 값이 들어올 것이고 
    // int[0]의 값으로는 시작시간, 종료시간이 담긴 배열 즉, 
    // int[0][0], int[0][1] 의 값이 들어오게 된다.
    // 여기서 o1의 값이 int[]이기 때문에 시작시간, 종료시간을 int[][] 표기가 아닌 
    // int[]의 표기로 나타내게 된다.
    // 또한 종료시간이 같을경우는 시작시간이 빠른 순으로 정렬한다.
    // sort에서는 o1-o2에서 양수의 값이 나오면 뒤로 보내고 음수이면 앞으로 가게된다.
    // o1의 값이 음수이면(o1 < o2) o1을 o2보다 앞으로 정렬한다.
    // o1의 값이 양수이면 (o1 > o2) o1을 o2보다 뒤로 정렬한다.
    // o1을 기준으로 나타낸 것이다.
    // ex) 1, 5, 3 / o1 = 5;
    // 5 - 3 > 0 => 1, 3, 5
    // o1이 o2보다 크기 떄문에 o1의 값을 뒤로 미룬다.
    // ex) 5, 1, 3 / o1 = 1;
    //  1 - 3 < 0 // 5, 1, 3
    // o1의 값이 o2보다 작기 때문에 값을 그대로둔다. [순서 유지가 아닌 값 비교로 인한 값 유지 ] 
    public int compare(int[] o1, int[] o2) {
        
        if(o1[1] == o2[1]) {
            return o1[0] - o2[0];
        }
        
        return o1[1] - o2[1];
    }
})
```

- 마지막으로 최대로 사용할 수 있는 회의실의 카운터 변수와 
- 이 전 종료 시간을 저장하는 변수를 만들고 N만큼 순회하면서 값을 비교한다.
```java
int count = 0;
int prev_end_time = 0;

for (int i = 0; i < N; i++) {
    
    // 직전 종료시간이 다음 회의 시작 시간보다 작거나 같다면 갱신
    // 직전 종료시간이 다음으로 들어갈 회의시간보다 작거나 같다면 갱신힌다.
    // 직전 종료시간이 오후 1시라고 가정한다면, 다음으로 들어갈 회의시간이 오후1시 또는 이후의 시간이라면
    // 갱신하는 것이다. 만약 직전 종료시간이 오후 1시 임에도 다음회의시간이 오후12시라면 들어갈 수 없기 때문에
    // 갱신하지 않는다.
    if(prev_end_time) <= time[i][0]) {
        prev_end_time = time[i][1];
        count++;
    }
}
```

##### 출처: https://st-lab.tistory.com/145