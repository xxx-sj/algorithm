# 문제
항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.
파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.
항승이는 길이가 L인 테이프를 무한개 가지고 있다.
항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.
물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.

# 입력
첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.

# 출력
첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.


##### 문제 해결 법
문제를 생각해보면 가장 맨 처음에는 테이프를 붙어야한다는 사실을 알 수 있다.  
입력받은 물 새는 곳을 오름차순으로 정렬하고 배열의 맨 처음 값 - 0.5 부터 테이프는 감쌀 수 있다.   
예를들어 1,2,100,101 에 물이새고 있고 테이프의 길이가 2일 경우 가장 맨 처음인 1에는 테이프를 반드시 붙여아한다.  
그렇다면 0.5 부터 테이프의 길이인 2.5까지 물이 새는 것을 감당할 수 있다.    
따라서 시작점은 1이 아닌, 0.5 부터 시작하면된다.   
이 후 N만큼 돌면서 시작점 0.5 부터 + 테이프 길이 의 값이 현재 배열의 값보다 클 경우 현재의 테이프로 충분히 커버할 수 있기    
때문에 넘어간다. 만약 테이프를 더한 값보다 현재 배열의 값이 클 경우 현재 배열의 - 0.5가 새로운 테이프의 시작점이 된다.   

- 물이새는 곳과 테이프의 길이를 입력받고 물이 새는 곳의 양만큼 배열을 생성한다.
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

StringTokenizer st = new StringTokenizer(br.readLine(), " ");
int N = Integer.parseInt(st.nextToken());
int L = Integer.parseInt(st.nextToken());

int[] arr = new int[N];
```
- 물이 새는 곳을 입력받는다. 입력받은 값은 오름차순으로 정렬한다.
```java
st = new StringTokenizer(br.readLine(), " ");
for(int i = 0; i < N; i++) {
    arr[i] = Integer.parseInt(st.nextToken());
}

Arrays.sort(arr);
```
- 가장 처음 테이프의 시작점을 초기화한다.
  - 배열의 처음 값 - 0.5이 첫 테이프의 시작점이다.
- 테이프를 1로 초기화한다.
```java
int tape = 1;
double startTapePoint = arr[0] - 0.5;
```
- for문을 돌면서 현재 테이프의 시작점 + 테이프의 길이와 현재 배열과 비교한다.
  - 테이프의 길이를 합한 값이 현재 배열의 값보다 크거나 같다면 현재의 테이프로도 
  - 커버가 가능하다는 의미이다.
  - 다음 배열로 넘어가 위 조건에 만족하지 않는다면 테이프의 시작점을 변경한다.
    - 새로운 테이프의 시작점은 현재 배열의 - 0.5 값이다.
```java
for(int i = 1; i < N; i++) {
    if(startTapePoint + L >= arr[i]) {
        continue;
    }
    startTapePoint = arr[i] - 0.5;
    tape++;
}

System.out.println(tape);
```