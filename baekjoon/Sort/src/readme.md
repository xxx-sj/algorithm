# 정렬

1. 내부정렬: 정렬한 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘
2. 외부정렬: 정렬한 데이터가 너무 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘
외부정렬은 내부 정렬을 응용한 것으로, 외부 정렬을 구현하려면 작업을 위한 파일 등이 필요하고 복잡한 알고리즘이다.  

### 버블정렬
앞에서 부터 시작하여 두 수를 비교해간다. 마지막에 가장 큰 수를 바닥에 보내는 것.   
이렇게 입력을 전체적으로 1번 처리하는 것을 패스라고 한다.   
가장 큰 수가 바닥에 위치하게 된다.  
일반적으로 n개의 원소가 있으면 (n - 1)번의 패스가 수행된다.     
(n - 1) + (n - 2) ... + (n - (n - 2)) + (n - (n - 1)) = n(n - 1)/ 2   
swap의 자리바꿈은 O(1) 시간이 걸린다. 그러므로 복잡도는   
n(n-1)/2 X O(1) = (1/2n^2 - 1/2n) x O(1) = O(n^2) x O(1) = O(n^2); 이다.   
( 1/2 2분의1)


### 단순 선택 정렬
가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘  
아직 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택하고 아직 정렬하지 않은 부분의    
첫번째 요소와 교환한다.
1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값을 선택한다.
2. 가장 작은 키의 값과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환한다.  
비교횟수는 (N^2 - N) / 2 회   
안정적이지 않다. 중복한 수에 대해서 순서가 뒤 바뀌는 것을 볼 수 있다.
O(n^2) 시간복잡도를 가진다.   
항상 일정한 시간 복잡도를 나타낸다. 즉, 입력에 민감하지 않은 알고리즘이다.


### 삽입정렬
정렬된 부분과 정렬이 안 된 부분으로 나누고, 정렬이 안 된 부분의 가장 왼쪽 원소를    
정렬된 부분의 적절한 위치에 삽입하여 정렬되도록 한다.   
삽입정렬은 1 부터 시작하여 N - 1 까지 진행하며 이 전 배열의 값과 비교하여 정렬한다.   
예를들어  {1,3,7,4,2,6,7} 이란 배열일 때, 시작은 idx = 1 부터 시작하며,  
i = 3 일때 i = 0 ~ 2 까지의 값과 비교한다. 비교해 나가다가 자신보다 작거나 같은 값을 만나면   
비교를 종료하고 i를 증가시킨다.   
```java
for(int i = 1; i < N; i++) {
    int target = a[i];

    for(int j = i - 1; j >= 0; j--) {

        if(target < a[j]) {
            a[j + 1] = a[j];
        } else {
             a[j + 1] = target;
            break;
        }
    }
}
```
위의 코드처럼 i는 targetIndex를 나타낸다.  하나의 지점이 되어    
이전 배열의 값과 비교하며 정렬해나간다.  
만약 현재 비교하려는 인덱스 j의 값이 target보다 크다면 a[j + 1] 에 a[j]값을 넣는다.   
따로 스왑하지 않는이유는 바깥 for문에 target이라고 값을 저장하고 있기 때문에   
만약 target보다 작거나 같은 수를 만난다면 거기서 비교를 끝내고 a[j + 1]에 target을 저장한다.   
여기서 [j + 1] 인 이유는 생각해보면 다음과 같다.   
[1, 3, 2]인 배열에서 target = [2] (idx = 2) 일 때 ,비교군은 idx= 1, idx = 0 이다.   
처음 j = 1 일때와 비교한다면 조건에 부합하므로 값을 (idx = 2)에 넣어야한다. 현재 비교하는 j의 값은 1 이므로 
j + 1 이 되는 것이다.    
다음으로 j = 0 일때를 생각해보자. j = 0 일때는 [1], [2] 에서 [1]이 더 작기 때문에 비교가 끝난다.   
따라서 idx = 1에 target값을 저장해야하는데, 현재 j의 값은 0 이므로 이 때도 j + 1 이 되는 것이다.   



역순에 가까울수록 매우 비효율적이며, 최악의 경우 O(N^2)의 시간 복잡도를 갖는다.   